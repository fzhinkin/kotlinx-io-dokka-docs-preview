<!doctype html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1" charset="UTF-8">
    <title>kotlinx-io-core</title>
<link href="../images/logo-icon.svg" rel="icon" type="image/svg"><script>var pathToRoot = "../";</script>    <script>const storage = localStorage.getItem("dokka-dark-mode")
    if (storage == null) {
        const osDarkSchemePreferred = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
        if (osDarkSchemePreferred === true) {
            document.getElementsByTagName("html")[0].classList.add("theme-dark")
        }
    } else {
        const savedDarkMode = JSON.parse(storage)
        if(savedDarkMode === true) {
            document.getElementsByTagName("html")[0].classList.add("theme-dark")
        }
    }
    </script>
<script type="text/javascript" src="../scripts/sourceset_dependencies.js" async></script>
<link href="../styles/style.css" rel="Stylesheet">
<link href="../styles/jetbrains-mono.css" rel="Stylesheet">
<link href="../styles/main.css" rel="Stylesheet">
<link href="../styles/prism.css" rel="Stylesheet">
<link href="../styles/logo-styles.css" rel="Stylesheet">
<script type="text/javascript" src="../scripts/clipboard.js" async></script>
<script type="text/javascript" src="../scripts/navigation-loader.js" async></script>
<script type="text/javascript" src="../scripts/platform-content-handler.js" async></script>
<script type="text/javascript" src="../scripts/main.js" defer></script>
<script type="text/javascript" src="../scripts/prism.js" async></script>
<script type="text/javascript" src="../scripts/symbol-parameters-wrapper_deferred.js" defer></script></head>
<body>
<div class="navigation-wrapper" id="navigation-wrapper">
    <div id="leftToggler"><span class="icon-toggler"></span></div>
    <div class="library-name">
<a href="../index.html">
<span>kotlinx-io</span>            </a>    </div>
    <div>0.2.0-alpha-dev1
    </div>
    <div class="pull-right d-flex">
        <div class="filter-section" id="filter-section">
                <button class="platform-tag platform-selector common-like" data-active="" data-filter=":kotlinx-io-core:dokkaHtmlPartial/commonMain">common</button>
                <button class="platform-tag platform-selector jvm-like" data-active="" data-filter=":kotlinx-io-core:dokkaHtmlPartial/jvmMain">jvm</button>
                <button class="platform-tag platform-selector common-like" data-active="" data-filter=":kotlinx-io-core:dokkaHtmlPartial/nativeMain">native</button>
        </div>
        <button id="theme-toggle-button"><span id="theme-toggle"></span></button>
        <div id="searchBar"></div>
    </div>
</div>
<div id="container">
    <div id="leftColumn">
        <div id="sideMenu"></div>
    </div>
    <div id="main">
<div class="main-content" id="content" pageids="kotlinx-io-core::////PointingToDeclaration//-1046884991">
  <div class="breadcrumbs"></div>
  <div class="cover ">
    <h1 class="cover"><span><span>kotlinx-io-core</span></span></h1>
    <div class="platform-hinted UnderCoverText with-platform-tabs" data-platform-hinted="data-platform-hinted">
      <div class="platform-bookmarks-row" data-toggle-list="data-toggle-list"><button class="platform-bookmark" data-filterable-current=":kotlinx-io-core:dokkaHtmlPartial/commonMain" data-filterable-set=":kotlinx-io-core:dokkaHtmlPartial/commonMain" data-active="" data-toggle=":kotlinx-io-core:dokkaHtmlPartial/commonMain">common</button><button class="platform-bookmark" data-filterable-current=":kotlinx-io-core:dokkaHtmlPartial/jvmMain" data-filterable-set=":kotlinx-io-core:dokkaHtmlPartial/jvmMain" data-toggle=":kotlinx-io-core:dokkaHtmlPartial/jvmMain">jvm</button><button class="platform-bookmark" data-filterable-current=":kotlinx-io-core:dokkaHtmlPartial/nativeMain" data-filterable-set=":kotlinx-io-core:dokkaHtmlPartial/nativeMain" data-toggle=":kotlinx-io-core:dokkaHtmlPartial/nativeMain">native</button></div>
<div class="content sourceset-dependent-content" data-active="" data-togglable=":kotlinx-io-core:dokkaHtmlPartial/commonMain"><p class="paragraph">The module provides core multiplatform IO primitives and integrates it with platform-specific APIs.</p><p class="paragraph"><code class="lang-kotlin">kotlinx-io</code> aims to provide a concise but powerful API along with efficient implementation.</p><p class="paragraph">The main interfaces for the IO interaction are <a href="kotlinx.io/-source/index.html">kotlinx.io.Source</a> and <a href="kotlinx.io/-sink/index.html">kotlinx.io.Sink</a> providing buffered read and  write operations for integer types, byte arrays, and other sources and sinks. There are also extension functions bringing support for strings and other types.  Implementations of these interfaces are built on top of <a href="kotlinx.io/-buffer/index.html">kotlinx.io.Buffer</a>, <a href="kotlinx.io/-raw-source/index.html">kotlinx.io.RawSource</a>, and <a href="kotlinx.io/-raw-sink/index.html">kotlinx.io.RawSink</a>.</p><p class="paragraph">A central part of the library, <a href="kotlinx.io/-buffer/index.html">kotlinx.io.Buffer</a>, is a container optimized to reduce memory allocations and to avoid data copying when possible.</p><p class="paragraph"><a href="kotlinx.io/-raw-source/index.html">kotlinx.io.RawSource</a> and <a href="kotlinx.io/-raw-sink/index.html">kotlinx.io.RawSink</a> are interfaces aimed for integration with anything that can provide  or receive data: network interfaces, files, etc. The module provides integration with some platform-specific IO APIs, but if something not yet supported by the library needs to be integrated, then these interfaces are exactly what should  be implemented for that.</p><p class="paragraph">Example below shows how to manually serialize an object to <a href="https://bsonspec.org/spec.html">BSON</a>  and then back to an object using <code class="lang-kotlin">kotlinx.io</code>. Please note that the example aimed to show <code class="lang-kotlin">kotlinx-io</code> API in action, rather than to provide a robust BSON-serialization.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">data class Message(val timestamp: Long, val text: String) {<br>    companion object<br>}<br><br>fun Message.toBson(sink: Sink) {<br>    val buffer = Buffer()<br>    buffer.writeByte(0x9)                        // UTC-timestamp field<br>        .writeUtf8("timestamp").writeByte(0)     // field name<br>        .writeLongLe(timestamp)                  // field value<br>        .writeByte(0x2)                          // string field<br>        .writeUtf8("text").writeByte(0)          // field name<br>        .writeIntLe(text.utf8Size().toInt() + 1) // field value: length followed by the string<br>        .writeUtf8(text).writeByte(0)<br>        .writeByte(0)                            // end of BSON document<br><br>    // Write document length and then its body<br>    sink.writeIntLe(buffer.size.toInt() + 4)<br>        .writeAll(buffer)<br>    sink.flush()<br>}<br><br>fun Message.Companion.fromBson(source: Source): Message {<br>    source.require(4)                                    // check if the source contains length<br>    val length = source.readIntLe() - 4L<br>    source.require(length)                               // check if the source contains the whole message<br><br>    fun readFieldName(source: Source): String {<br>        val delimiterOffset = source.indexOf(0)          // find offset of the 0-byte terminating the name<br>        check(delimiterOffset &gt;= 0)                      // indexOf return -1 if value not found<br>        val fieldName = source.readUtf8(delimiterOffset) // read the string until terminator<br>        source.skip(1)                                   // skip the terminator<br>        return fieldName<br>    }<br>    <br>    // for simplicity, let's assume that the order of fields matches serialization order<br>    var tag = source.readByte().toInt()                // read the field type<br>    check(tag == 0x9 &amp;&amp; readFieldName(source) == "timestamp")<br>    val timestamp = source.readLongLe()                // read long value<br>    tag = source.readByte().toInt()<br>    check(tag == 0x2 &amp;&amp; readFieldName(source) == "text")<br>    val textLen = source.readIntLe() - 1L              // read string length (it includes the terminator)<br>    val text = source.readUtf8(textLen)                // read value<br>    source.skip(1)                                     // skip terminator<br>    source.skip(1)                                     // skip end of the document<br>    return Message(timestamp, text)<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div></div><div class="content sourceset-dependent-content" data-togglable=":kotlinx-io-core:dokkaHtmlPartial/jvmMain"><p class="paragraph">The module provides core multiplatform IO primitives and integrates it with platform-specific APIs.</p><p class="paragraph"><code class="lang-kotlin">kotlinx-io</code> aims to provide a concise but powerful API along with efficient implementation.</p><p class="paragraph">The main interfaces for the IO interaction are <a href="kotlinx.io/-source/index.html">kotlinx.io.Source</a> and <a href="kotlinx.io/-sink/index.html">kotlinx.io.Sink</a> providing buffered read and  write operations for integer types, byte arrays, and other sources and sinks. There are also extension functions bringing support for strings and other types.  Implementations of these interfaces are built on top of <a href="kotlinx.io/-buffer/index.html">kotlinx.io.Buffer</a>, <a href="../kotlinx-io-core/kotlinx.io/-raw-source/index.html">kotlinx.io.RawSource</a>, and <a href="kotlinx.io/-raw-sink/index.html">kotlinx.io.RawSink</a>.</p><p class="paragraph">A central part of the library, <a href="kotlinx.io/-buffer/index.html">kotlinx.io.Buffer</a>, is a container optimized to reduce memory allocations and to avoid data copying when possible.</p><p class="paragraph"><a href="../kotlinx-io-core/kotlinx.io/-raw-source/index.html">kotlinx.io.RawSource</a> and <a href="kotlinx.io/-raw-sink/index.html">kotlinx.io.RawSink</a> are interfaces aimed for integration with anything that can provide  or receive data: network interfaces, files, etc. The module provides integration with some platform-specific IO APIs, but if something not yet supported by the library needs to be integrated, then these interfaces are exactly what should  be implemented for that.</p><p class="paragraph">Example below shows how to manually serialize an object to <a href="https://bsonspec.org/spec.html">BSON</a>  and then back to an object using <code class="lang-kotlin">kotlinx.io</code>. Please note that the example aimed to show <code class="lang-kotlin">kotlinx-io</code> API in action, rather than to provide a robust BSON-serialization.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">data class Message(val timestamp: Long, val text: String) {<br>    companion object<br>}<br><br>fun Message.toBson(sink: Sink) {<br>    val buffer = Buffer()<br>    buffer.writeByte(0x9)                        // UTC-timestamp field<br>        .writeUtf8("timestamp").writeByte(0)     // field name<br>        .writeLongLe(timestamp)                  // field value<br>        .writeByte(0x2)                          // string field<br>        .writeUtf8("text").writeByte(0)          // field name<br>        .writeIntLe(text.utf8Size().toInt() + 1) // field value: length followed by the string<br>        .writeUtf8(text).writeByte(0)<br>        .writeByte(0)                            // end of BSON document<br><br>    // Write document length and then its body<br>    sink.writeIntLe(buffer.size.toInt() + 4)<br>        .writeAll(buffer)<br>    sink.flush()<br>}<br><br>fun Message.Companion.fromBson(source: Source): Message {<br>    source.require(4)                                    // check if the source contains length<br>    val length = source.readIntLe() - 4L<br>    source.require(length)                               // check if the source contains the whole message<br><br>    fun readFieldName(source: Source): String {<br>        val delimiterOffset = source.indexOf(0)          // find offset of the 0-byte terminating the name<br>        check(delimiterOffset &gt;= 0)                      // indexOf return -1 if value not found<br>        val fieldName = source.readUtf8(delimiterOffset) // read the string until terminator<br>        source.skip(1)                                   // skip the terminator<br>        return fieldName<br>    }<br>    <br>    // for simplicity, let's assume that the order of fields matches serialization order<br>    var tag = source.readByte().toInt()                // read the field type<br>    check(tag == 0x9 &amp;&amp; readFieldName(source) == "timestamp")<br>    val timestamp = source.readLongLe()                // read long value<br>    tag = source.readByte().toInt()<br>    check(tag == 0x2 &amp;&amp; readFieldName(source) == "text")<br>    val textLen = source.readIntLe() - 1L              // read string length (it includes the terminator)<br>    val text = source.readUtf8(textLen)                // read value<br>    source.skip(1)                                     // skip terminator<br>    source.skip(1)                                     // skip end of the document<br>    return Message(timestamp, text)<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div></div><div class="content sourceset-dependent-content" data-togglable=":kotlinx-io-core:dokkaHtmlPartial/nativeMain"><p class="paragraph">The module provides core multiplatform IO primitives and integrates it with platform-specific APIs.</p><p class="paragraph"><code class="lang-kotlin">kotlinx-io</code> aims to provide a concise but powerful API along with efficient implementation.</p><p class="paragraph">The main interfaces for the IO interaction are <a href="kotlinx.io/-source/index.html">kotlinx.io.Source</a> and <a href="kotlinx.io/-sink/index.html">kotlinx.io.Sink</a> providing buffered read and  write operations for integer types, byte arrays, and other sources and sinks. There are also extension functions bringing support for strings and other types.  Implementations of these interfaces are built on top of <a href="kotlinx.io/-buffer/index.html">kotlinx.io.Buffer</a>, <a href="../kotlinx-io-core/kotlinx.io/-raw-source/index.html">kotlinx.io.RawSource</a>, and <a href="kotlinx.io/-raw-sink/index.html">kotlinx.io.RawSink</a>.</p><p class="paragraph">A central part of the library, <a href="kotlinx.io/-buffer/index.html">kotlinx.io.Buffer</a>, is a container optimized to reduce memory allocations and to avoid data copying when possible.</p><p class="paragraph"><a href="../kotlinx-io-core/kotlinx.io/-raw-source/index.html">kotlinx.io.RawSource</a> and <a href="kotlinx.io/-raw-sink/index.html">kotlinx.io.RawSink</a> are interfaces aimed for integration with anything that can provide  or receive data: network interfaces, files, etc. The module provides integration with some platform-specific IO APIs, but if something not yet supported by the library needs to be integrated, then these interfaces are exactly what should  be implemented for that.</p><p class="paragraph">Example below shows how to manually serialize an object to <a href="https://bsonspec.org/spec.html">BSON</a>  and then back to an object using <code class="lang-kotlin">kotlinx.io</code>. Please note that the example aimed to show <code class="lang-kotlin">kotlinx-io</code> API in action, rather than to provide a robust BSON-serialization.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">data class Message(val timestamp: Long, val text: String) {<br>    companion object<br>}<br><br>fun Message.toBson(sink: Sink) {<br>    val buffer = Buffer()<br>    buffer.writeByte(0x9)                        // UTC-timestamp field<br>        .writeUtf8("timestamp").writeByte(0)     // field name<br>        .writeLongLe(timestamp)                  // field value<br>        .writeByte(0x2)                          // string field<br>        .writeUtf8("text").writeByte(0)          // field name<br>        .writeIntLe(text.utf8Size().toInt() + 1) // field value: length followed by the string<br>        .writeUtf8(text).writeByte(0)<br>        .writeByte(0)                            // end of BSON document<br><br>    // Write document length and then its body<br>    sink.writeIntLe(buffer.size.toInt() + 4)<br>        .writeAll(buffer)<br>    sink.flush()<br>}<br><br>fun Message.Companion.fromBson(source: Source): Message {<br>    source.require(4)                                    // check if the source contains length<br>    val length = source.readIntLe() - 4L<br>    source.require(length)                               // check if the source contains the whole message<br><br>    fun readFieldName(source: Source): String {<br>        val delimiterOffset = source.indexOf(0)          // find offset of the 0-byte terminating the name<br>        check(delimiterOffset &gt;= 0)                      // indexOf return -1 if value not found<br>        val fieldName = source.readUtf8(delimiterOffset) // read the string until terminator<br>        source.skip(1)                                   // skip the terminator<br>        return fieldName<br>    }<br>    <br>    // for simplicity, let's assume that the order of fields matches serialization order<br>    var tag = source.readByte().toInt()                // read the field type<br>    check(tag == 0x9 &amp;&amp; readFieldName(source) == "timestamp")<br>    val timestamp = source.readLongLe()                // read long value<br>    tag = source.readByte().toInt()<br>    check(tag == 0x2 &amp;&amp; readFieldName(source) == "text")<br>    val textLen = source.readIntLe() - 1L              // read string length (it includes the terminator)<br>    val text = source.readUtf8(textLen)                // read value<br>    source.skip(1)                                     // skip terminator<br>    source.skip(1)                                     // skip end of the document<br>    return Message(timestamp, text)<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div></div>    </div>
  </div>
  <h2 class="">Packages</h2>
  <div class="table"><a data-name="-1247902337%2FPackages%2F-1046884991" anchor-label="kotlinx.io" id="-1247902337%2FPackages%2F-1046884991" data-filterable-set=":kotlinx-io-core:dokkaHtmlPartial/commonMain :kotlinx-io-core:dokkaHtmlPartial/jvmMain :kotlinx-io-core:dokkaHtmlPartial/nativeMain"></a>
    <div class="table-row" data-filterable-current=":kotlinx-io-core:dokkaHtmlPartial/commonMain :kotlinx-io-core:dokkaHtmlPartial/jvmMain :kotlinx-io-core:dokkaHtmlPartial/nativeMain" data-filterable-set=":kotlinx-io-core:dokkaHtmlPartial/commonMain :kotlinx-io-core:dokkaHtmlPartial/jvmMain :kotlinx-io-core:dokkaHtmlPartial/nativeMain">
      <div>
        <div class="main-subrow ">
          <div class=""><span class="inline-flex">
              <div><a href="kotlinx.io/index.html">kotlinx.io</a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="-1247902337%2FPackages%2F-1046884991"></span>
                <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
              </span></span></div>
          <div class="pull-right">
            <div class="platform-tags no-gutters">
              <div class="platform-tag common-like">common</div>
              <div class="platform-tag jvm-like">jvm</div>
              <div class="platform-tag common-like">native</div>
            </div>
          </div>
        </div>
        <div><span class="brief-comment"><a data-name="-1247902337%2FPackages%2F-1046884991" anchor-label="kotlinx.io" id="-1247902337%2FPackages%2F-1046884991" data-filterable-set=":kotlinx-io-core:dokkaHtmlPartial/commonMain :kotlinx-io-core:dokkaHtmlPartial/jvmMain :kotlinx-io-core:dokkaHtmlPartial/nativeMain"></a>
            <p class="paragraph">Core IO primitives.</p>
          </span></div>
      </div>
    </div>
<a data-name="461658504%2FPackages%2F-1046884991" anchor-label="kotlinx.io.files" id="461658504%2FPackages%2F-1046884991" data-filterable-set=":kotlinx-io-core:dokkaHtmlPartial/commonMain :kotlinx-io-core:dokkaHtmlPartial/jvmMain :kotlinx-io-core:dokkaHtmlPartial/nativeMain"></a>
    <div class="table-row" data-filterable-current=":kotlinx-io-core:dokkaHtmlPartial/commonMain :kotlinx-io-core:dokkaHtmlPartial/jvmMain :kotlinx-io-core:dokkaHtmlPartial/nativeMain" data-filterable-set=":kotlinx-io-core:dokkaHtmlPartial/commonMain :kotlinx-io-core:dokkaHtmlPartial/jvmMain :kotlinx-io-core:dokkaHtmlPartial/nativeMain">
      <div>
        <div class="main-subrow ">
          <div class=""><span class="inline-flex">
              <div><a href="kotlinx.io.files/index.html">kotlinx.io.files</a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="461658504%2FPackages%2F-1046884991"></span>
                <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
              </span></span></div>
          <div class="pull-right">
            <div class="platform-tags no-gutters">
              <div class="platform-tag common-like">common</div>
              <div class="platform-tag jvm-like">jvm</div>
              <div class="platform-tag common-like">native</div>
            </div>
          </div>
        </div>
        <div><span class="brief-comment"><a data-name="461658504%2FPackages%2F-1046884991" anchor-label="kotlinx.io.files" id="461658504%2FPackages%2F-1046884991" data-filterable-set=":kotlinx-io-core:dokkaHtmlPartial/commonMain :kotlinx-io-core:dokkaHtmlPartial/jvmMain :kotlinx-io-core:dokkaHtmlPartial/nativeMain"></a>
            <p class="paragraph">Basic API for working with files.</p>
          </span></div>
      </div>
    </div>
  </div>
</div>
      <div class="footer">
        <span class="go-to-top-icon"><a href="#content" id="go-to-top-link"></a></span><span>Â© 2023 Copyright</span><span class="pull-right"><span>Generated by </span><a href="https://github.com/Kotlin/dokka"><span>dokka</span><span class="padded-icon"></span></a></span>
      </div>
    </div>
</div>
</body>
</html>

